#!/usr/bin/env python3

# Script to convert Vivado `.bit` files to PYNQ `.bin` files
#
# The `.bin` files optionally generated by Vivado seem to have the wrong format
# to be flashed by the sysfs interface on the PYNQ. Specifically, all the data
# has the wrong endianness. This script does the conversion correctly. Most of
# the code was copied from PYNQ.

import sys

import numpy as np
import struct

# ------------------------------------------------------------------------------
# See: third-party/PYNQ/pynq/pl_server/embedded_device.py:bit2bin
# See: third-party/PYNQ/pynq/pl_server/embedded_device.py:parse_bit_header

def parse_bit_header(bit_data):
    """The method to parse the header of a bitstream.

    The returned dictionary has the following keys:
    "design": str, the Vivado project name that generated the bitstream;
    "version": str, the Vivado tool version that generated the bitstream;
    "part": str, the Xilinx part name that the bitstream targets;
    "date": str, the date the bitstream was compiled on;
    "time": str, the time the bitstream finished compilation;
    "length": int, total length of the bitstream (in bytes);
    "data": binary, binary data in .bit file format

    Returns
    -------
    Dict
        A dictionary containing the header information.

    Note
    ----
    Implemented based on: https://blog.aeste.my/?p=2892

    """
    finished = False
    offset = 0
    contents = bit_data
    bit_dict = {}

    # Strip the (2+n)-byte first field (2-bit length, n-bit data)
    length = struct.unpack(">h", contents[offset : offset + 2])[0]
    offset += 2 + length

    # Strip a two-byte unknown field (usually 1)
    offset += 2

    # Strip the remaining headers. 0x65 signals the bit data field
    while not finished:
        desc = contents[offset]
        offset += 1

        if desc != 0x65:
            length = struct.unpack(">h", contents[offset : offset + 2])[0]
            offset += 2
            fmt = ">{}s".format(length)
            data = struct.unpack(fmt, contents[offset : offset + length])[0]
            data = data.decode("ascii")[:-1]
            offset += length

        if desc == 0x61:
            s = data.split(";")
            bit_dict["design"] = s[0]
            bit_dict["version"] = s[-1]
        elif desc == 0x62:
            bit_dict["part"] = data
        elif desc == 0x63:
            bit_dict["date"] = data
        elif desc == 0x64:
            bit_dict["time"] = data
        elif desc == 0x65:
            finished = True
            length = struct.unpack(">i", contents[offset : offset + 4])[0]
            offset += 4
            # Expected length values can be verified in the chip TRM
            bit_dict["length"] = str(length)
            if length + offset != len(contents):
                raise RuntimeError("Invalid length found")
            bit_dict["data"] = contents[offset : offset + length]
        else:
            raise RuntimeError("Unknown field: {}".format(hex(desc)))
    return bit_dict


def bit2bin(bit_data):
    """Convert an in-memory .bit file to .bin data for fpga_manager"""
    bit_dict = parse_bit_header(bit_data)
    bit_buffer = np.frombuffer(bit_dict["data"], "i4")
    bin_buffer = bit_buffer.byteswap()
    return bytes(bin_buffer)

# ------------------------------------------------------------------------------

def usage():
    """Print the usage and exit with an error"""
    print("Usage: python3 bit2bin.py INPUT OUTPUT")
    print("Convert the INPUT `.bit` file to the OUTPUT `.bin` file compatible with the PYNQ")
    sys.exit(1)

def main():

    # Check our arguments are correct. If they are, parse them.
    if len(sys.argv) != 3:
        usage()
    input_filename = sys.argv[1]
    output_filename = sys.argv[2]

    # Read the input into memory
    with open(input_filename, 'rb') as input_fd:
        input_data = input_fd.read()

    # Convert
    output_data = bit2bin(input_data)

    # Write
    with open(output_filename, 'wb') as output_fd:
        output_fd.write(output_data)

if __name__ == '__main__':
    main()
